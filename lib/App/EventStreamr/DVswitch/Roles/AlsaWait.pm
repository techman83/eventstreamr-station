package App::EventStreamr::DVswitch::Roles::AlsaWait;

use v5.010;
use strict;
use warnings;
use Method::Signatures 20140224; # libmethod-signatures-perl
use POSIX 'strftime';
use File::Path 'make_path';
use JSON 'from_json';
use Proc::ProcessTable; # libproc-processtable-perl

use Moo::Role; # libmoo-perl

# ABSTRACT: Wait for Alsa on Mixer to Start

# VERSION: Generated by DZP::OurPkg:Version

=head1 SYNOPSIS

This is a role wraps around the 'run_stop' of a process.

=head1 DESCRIPTION

This is a Role that can be consumed to ensure the path exists 
before allowing the record process to take place.

It requires a 'run_stop' method, so really should only be consumed
by processes that extend L<App::EventStreamr::Process>.


=cut

requires 'run_stop','status','config','id','type';


# TODO: It Makes _A LOT_ of assumptions, so I wouldn't pull this into master

method _alsa_started() {
  # THIS IS YUCKY! But the API needs improvement, so will look at that first.
  if (! $self->config->alsa_running) {
    $self->status->waiting($self->{id},$self->{type},"waiting_alsa") if ((time % 10) == 0 );
    $self->debug("Checking for alsa process to have started");
    my $status = $self->config->http->get("http://".$self->config->{mixer}{host}.":3000/status");
    
    my $content;

    eval {
      $content = from_json($status->{content});
    };

    if ($content) { 
      my @statuses; 
      
      # <Forgive me...>
      foreach my $key (keys %{$content}) {
        if (defined $content->{$key}{status}) {
          foreach my $status (keys %{$content->{$key}{status}}) {
            if (defined $content->{$key}{status}{$status}{type}) {
              push(@statuses, $content->{$key}{status}{$status});
            }
          }
        }
      }
      # </Forgive me...>
      
      
      $self->debug({filter => \&Data::Dumper::Dumper,
                    value  => \@statuses}) if ($self->is_debug());

      my @alsa = grep { $_->{type} =~ /alsa/ } @statuses;
      if (@alsa) {
        $self->config->alsa_running($alsa[0]->{running});
        return $alsa[0]->{running};
      } else {
        $self->debug("Alsa process not yet started");
        return 0;
      }
    } else {
      return 0;
    }
  } else {
    return 1;
  }
}

around 'run_stop' => sub {
  my $orig = shift;
  my $self = shift;
  
  if ( $self->_alsa_started() ) {
    $orig->($self);
  } else {
    $self->status->threshold($self->{id},'alsa_not_started');
  }
};

1;
